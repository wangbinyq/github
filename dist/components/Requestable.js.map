{"version":3,"names":[],"mappings":"","sources":["Requestable.js"],"sourcesContent":["/**\r\n * @file\r\n * @copyright  2016 Yahoo Inc.\r\n * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.\r\n *             Github.js is freely distributable.\r\n */\r\n\r\nimport axios from 'axios';\r\nimport debug from 'debug';\r\nimport {Base64} from 'js-base64';\r\n\r\nconst log = debug('github:request');\r\n\r\n/**\r\n * The error structure returned when a network call fails\r\n */\r\nclass ResponseError extends Error {\r\n   /**\r\n    * Construct a new ResponseError\r\n    * @param {string} message - an message to return instead of the the default error message\r\n    * @param {string} path - the requested path\r\n    * @param {Object} response - the object returned by Axios\r\n    */\r\n   constructor(message, path, response) {\r\n      super(message);\r\n      this.path = path;\r\n      this.request = response.config;\r\n      this.response = (response || {}).response || response;\r\n      this.status = response.status;\r\n   }\r\n}\r\n\r\n/**\r\n * Requestable wraps the logic for making http requests to the API\r\n */\r\nclass Requestable {\r\n   /**\r\n    * Either a username and password or an oauth token for Github\r\n    * @typedef {Object} Requestable.auth\r\n    * @prop {string} [username] - the Github username\r\n    * @prop {string} [password] - the user's password\r\n    * @prop {token} [token] - an OAuth token\r\n    */\r\n   /**\r\n    * Initialize the http internals.\r\n    * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is\r\n    *                                  not provided request will be made unauthenticated\r\n    * @param {string} [apiBase=https://api.github.com] - the base Github API URL\r\n    * @param {string} [AcceptHeader=v3] - the accept header for the requests\r\n    */\r\n   constructor(auth, apiBase, AcceptHeader) {\r\n      this.__apiBase = apiBase || 'https://api.github.com';\r\n      this.__auth = {\r\n         token: auth.token,\r\n         username: auth.username,\r\n         password: auth.password,\r\n      };\r\n      this.__AcceptHeader = AcceptHeader || 'v3';\r\n\r\n      if (auth.token) {\r\n         this.__authorizationHeader = 'token ' + auth.token;\r\n      } else if (auth.username && auth.password) {\r\n         this.__authorizationHeader = 'Basic ' + Base64.encode(auth.username + ':' + auth.password);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Compute the URL to use to make a request.\r\n    * @private\r\n    * @param {string} path - either a URL relative to the API base or an absolute URL\r\n    * @return {string} - the URL to use\r\n    */\r\n   __getURL(path) {\r\n      let url = path;\r\n\r\n      if (path.indexOf('//') === -1) {\r\n         url = this.__apiBase + path;\r\n      }\r\n\r\n      let newCacheBuster = 'timestamp=' + new Date().getTime();\r\n      return url.replace(/(timestamp=\\d+)/, newCacheBuster);\r\n   }\r\n\r\n   /**\r\n    * Compute the headers required for an API request.\r\n    * @private\r\n    * @param {boolean} raw - if the request should be treated as JSON or as a raw request\r\n    * @param {string} AcceptHeader - the accept header for the request\r\n    * @return {Object} - the headers to use in the request\r\n    */\r\n   __getRequestHeaders(raw, AcceptHeader) {\r\n      let headers = {\r\n         'Content-Type': 'application/json;charset=UTF-8',\r\n         'Accept': 'application/vnd.github.' + (AcceptHeader || this.__AcceptHeader),\r\n      };\r\n\r\n      if (raw) {\r\n         headers.Accept += '.raw';\r\n      }\r\n      headers.Accept += '+json';\r\n\r\n      if (this.__authorizationHeader) {\r\n         headers.Authorization = this.__authorizationHeader;\r\n      }\r\n\r\n      return headers;\r\n   }\r\n\r\n   /**\r\n    * Sets the default options for API requests\r\n    * @protected\r\n    * @param {Object} [requestOptions={}] - the current options for the request\r\n    * @return {Object} - the options to pass to the request\r\n    */\r\n   _getOptionsWithDefaults(requestOptions = {}) {\r\n      if (!(requestOptions.visibility || requestOptions.affiliation)) {\r\n         requestOptions.type = requestOptions.type || 'all';\r\n      }\r\n      requestOptions.sort = requestOptions.sort || 'updated';\r\n      requestOptions.per_page = requestOptions.per_page || '100'; // eslint-disable-line\r\n\r\n      return requestOptions;\r\n   }\r\n\r\n   /**\r\n    * if a `Date` is passed to this function it will be converted to an ISO string\r\n    * @param {*} date - the object to attempt to cooerce into an ISO date string\r\n    * @return {string} - the ISO representation of `date` or whatever was passed in if it was not a date\r\n    */\r\n   _dateToISO(date) {\r\n      if (date && (date instanceof Date)) {\r\n         date = date.toISOString();\r\n      }\r\n\r\n      return date;\r\n   }\r\n\r\n   /**\r\n    * A function that receives the result of the API request.\r\n    * @callback Requestable.callback\r\n    * @param {Requestable.Error} error - the error returned by the API or `null`\r\n    * @param {(Object|true)} result - the data returned by the API or `true` if the API returns `204 No Content`\r\n    * @param {Object} request - the raw {@linkcode https://github.com/mzabriskie/axios#response-schema Response}\r\n    */\r\n   /**\r\n    * Make a request.\r\n    * @param {string} method - the method for the request (GET, PUT, POST, DELETE)\r\n    * @param {string} path - the path for the request\r\n    * @param {*} [data] - the data to send to the server. For HTTP methods that don't have a body the data\r\n    *                   will be sent as query parameters\r\n    * @param {Requestable.callback} [cb] - the callback for the request\r\n    * @param {boolean} [raw=false] - if the request should be sent as raw. If this is a falsy value then the\r\n    *                              request will be made as JSON\r\n    * @return {Promise} - the Promise for the http request\r\n    */\r\n   _request(method, path, data, cb, raw) {\r\n      const url = this.__getURL(path);\r\n\r\n      const AcceptHeader = (data || {}).AcceptHeader;\r\n      if (AcceptHeader) {\r\n         delete data.AcceptHeader;\r\n      }\r\n      const headers = this.__getRequestHeaders(raw, AcceptHeader);\r\n\r\n      let queryParams = {};\r\n\r\n      const shouldUseDataAsParams = data && (typeof data === 'object') && methodHasNoBody(method);\r\n      if (shouldUseDataAsParams) {\r\n         queryParams = data;\r\n         data = undefined;\r\n      }\r\n\r\n      const config = {\r\n         url: url,\r\n         method: method,\r\n         headers: headers,\r\n         params: queryParams,\r\n         data: data,\r\n         responseType: raw ? 'text' : 'json',\r\n      };\r\n\r\n      log(`${config.method} to ${config.url}`);\r\n      const requestPromise = axios(config).catch(callbackErrorOrThrow(cb, path));\r\n\r\n      if (cb) {\r\n         requestPromise.then((response) => {\r\n            if (response.data && Object.keys(response.data).length > 0) {\r\n               // When data has results\r\n               cb(null, response.data, response);\r\n            } else if (config.method !== 'GET' && Object.keys(response.data).length < 1) {\r\n               // True when successful submit a request and receive a empty object\r\n               cb(null, (response.status < 300), response);\r\n            } else {\r\n               cb(null, response.data, response);\r\n            }\r\n         });\r\n      }\r\n\r\n      return requestPromise;\r\n   }\r\n\r\n   /**\r\n    * Make a request to an endpoint the returns 204 when true and 404 when false\r\n    * @param {string} path - the path to request\r\n    * @param {Object} data - any query parameters for the request\r\n    * @param {Requestable.callback} cb - the callback that will receive `true` or `false`\r\n    * @param {method} [method=GET] - HTTP Method to use\r\n    * @return {Promise} - the promise for the http request\r\n    */\r\n   _request204or404(path, data, cb, method = 'GET') {\r\n      return this._request(method, path, data)\r\n         .then(function success(response) {\r\n            if (cb) {\r\n               cb(null, true, response);\r\n            }\r\n            return true;\r\n         }, function failure(response) {\r\n            if (response.response.status === 404) {\r\n               if (cb) {\r\n                  cb(null, false, response);\r\n               }\r\n               return false;\r\n            }\r\n\r\n            if (cb) {\r\n               cb(response);\r\n            }\r\n            throw response;\r\n         });\r\n   }\r\n\r\n   /**\r\n    * Make a request and fetch all the available data. Github will paginate responses so for queries\r\n    * that might span multiple pages this method is preferred to {@link Requestable#request}\r\n    * @param {string} path - the path to request\r\n    * @param {Object} options - the query parameters to include\r\n    * @param {Requestable.callback} [cb] - the function to receive the data. The returned data will always be an array.\r\n    * @param {Object[]} results - the partial results. This argument is intended for interal use only.\r\n    * @return {Promise} - a promise which will resolve when all pages have been fetched\r\n    * @deprecated This will be folded into {@link Requestable#_request} in the 2.0 release.\r\n    */\r\n   _requestAllPages(path, options, cb, results) {\r\n      results = results || [];\r\n\r\n      return this._request('GET', path, options)\r\n         .then((response) => {\r\n            let thisGroup;\r\n            if (response.data instanceof Array) {\r\n               thisGroup = response.data;\r\n            } else if (response.data.items instanceof Array) {\r\n               thisGroup = response.data.items;\r\n            } else {\r\n               let message = `cannot figure out how to append ${response.data} to the result set`;\r\n               throw new ResponseError(message, path, response);\r\n            }\r\n            results.push(...thisGroup);\r\n\r\n            const nextUrl = getNextPage(response.headers.link);\r\n            if (nextUrl && typeof options.page !== 'number') {\r\n               log(`getting next page: ${nextUrl}`);\r\n               return this._requestAllPages(nextUrl, options, cb, results);\r\n            }\r\n\r\n            if (cb) {\r\n               cb(null, results, response);\r\n            }\r\n\r\n            response.data = results;\r\n            return response;\r\n         }).catch(callbackErrorOrThrow(cb, path));\r\n   }\r\n}\r\n\r\nmodule.exports = Requestable;\r\n\r\n// ////////////////////////// //\r\n//  Private helper functions  //\r\n// ////////////////////////// //\r\nconst METHODS_WITH_NO_BODY = ['GET', 'HEAD', 'DELETE'];\r\nfunction methodHasNoBody(method) {\r\n   return METHODS_WITH_NO_BODY.indexOf(method) !== -1;\r\n}\r\n\r\nfunction getNextPage(linksHeader = '') {\r\n   const links = linksHeader.split(/\\s*,\\s*/); // splits and strips the urls\r\n   return links.reduce(function(nextUrl, link) {\r\n      if (link.search(/rel=\"next\"/) !== -1) {\r\n         return (link.match(/<(.*)>/) || [])[1];\r\n      }\r\n\r\n      return nextUrl;\r\n   }, undefined);\r\n}\r\n\r\nfunction callbackErrorOrThrow(cb, path) {\r\n   return function handler(object) {\r\n      let error;\r\n      if (object.hasOwnProperty('config')) {\r\n         const {response: {status, statusText}, config: {method, url}} = object;\r\n         let message = (`${status} error making request ${method} ${url}: \"${statusText}\"`);\r\n         error = new ResponseError(message, path, object);\r\n         log(`${message} ${JSON.stringify(object.data)}`);\r\n      } else {\r\n         error = object;\r\n      }\r\n      if (cb) {\r\n         log('going to error callback');\r\n         cb(error);\r\n      } else {\r\n         log('throwing error');\r\n         throw error;\r\n      }\r\n   };\r\n}\r\n"],"file":"Requestable.js"}